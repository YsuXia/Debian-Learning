digraph platform_bus{
	node[shape=record];

	subgraph cluster_struct_bus_type{
		label="struct bus_type";
		bgcolor="pink";
		"struct bus_type"[label="{
		const char      *name
    |const char      *dev_name
    |struct device       *dev_root
    |struct device_attribute *dev_attrs
    |const struct attribute_group **bus_groups;
    |const struct attribute_group **dev_groups;
    |const struct attribute_group **drv_groups;
    |int (*match)(struct device *dev, struct device_driver *drv);
    |int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
    |int (*probe)(struct device *dev);
    |int (*remove)(struct device *dev);
    |void (*shutdown)(struct device *dev);
    |int (*online)(struct device *dev);
    |int (*offline)(struct device *dev);
    |int (*suspend)(struct device *dev, pm_message_t state);
    |int (*resume)(struct device *dev);
    |const struct dev_pm_ops *pm;
    |const struct iommu_ops *iommu_ops;
    |<subsys>struct subsys_private *p;
    |struct lock_class_key lock_key;
		}"];
	}

	"struct bus_type":subsys->"struct subsys_private"[color=blue];

	subgraph cluster_struct_subsys_private{
		label="struct subsys_private";
		"struct subsys_private"[label="{
		struct kset subsys;
    |<dev_kset>struct kset *devices_kset;
    |struct list_head interfaces;
    |struct mutex mutex;
    |struct kset *drivers_kset;
    |<devices>struct klist klist_devices;
    |struct klist klist_drivers;
    |struct blocking_notifier_head bus_notifier;
    |unsigned int drivers_autoprobe:1;
    |struct bus_type *bus;
    |struct kset glue_dirs;
    |struct class *class;
	}"];
	}
	"struct subsys_private":dev_kset->"struct kset"[color=red];
	"struct subsys_private":devices->"struct klist"[color=red];

	subgraph cluster_struct_kset{
		label="struct kset";
		"struct kset"[label="{
		struct list_head list;
    |spinlock_t list_lock;
    |<obj>struct kobject kobj;
    |const struct kset_uevent_ops *uevent_ops
	}"];
	}

	"struct kset":obj->"struct kobject"[color=blue];
	subgraph cluster_struct_dev_pin_info{
		label="struct dev_pin_info";
		"struct dev_pin_info"[label="{
			<p>struct pinctrl *p;
    |struct pinctrl_state *default_state;
    |struct pinctrl_state *sleep_state;
    |struct pinctrl_state *idle_state;
		}"];
	}
	"struct device":pins->"struct dev_pin_info"[color=blue];
	"struct dev_pin_info":p->"struct pinctrl";

	subgraph cluster_struct_pinctrl{
		label="struct pinctrl";
		"struct pinctrl"[label="{
		struct list_head node;
    |struct device *dev;
    |struct list_head states;
    |struct pinctrl_state *state;
    |struct list_head dt_maps;
    |struct kref users;
	}"];
	}

	subgraph cluster_struct_pinctrl_dev{
		label="struct pinctrl_dev";
		"struct pinctrl_dev"[label="{
		struct list_head node****用于挂接到全局的controller list(pinctrldev_list)当中去
    |<desc>struct pinctrl_desc *desc*****初始化pin controller用到的描述符
    |struct radix_tree_root pin_desc_tree;
    |<ranges>struct list_head gpio_ranges****由该controller处理的gpio ranges, 系统当中所有的gpio是分片的**
    |struct device *dev;
    |struct module *owner;
    |void *driver_data;
    |<p>struct pinctrl *p;
    |struct pinctrl_state *hog_default;
    |struct pinctrl_state *hog_sleep;
    |struct mutex mutex;
    |struct dentry *device_root;
	}"];
	}
	"struct pinctrl_dev":ranges->"struct pinctrl_gpio_range"[color=red];
	subgraph cluster_struct_pinctrl_gpio_range{
		label="struct pinctrl_gpio_range";
		"struct pinctrl_gpio_range"[label="{
			struct list_head node
    |const char *name
    |unsigned int id
    |unsigned int base
    |unsigned int pin_base
    |unsigned const *pins
    |unsigned int npins
    |struct gpio_chip *gc
		}"];
	}

	"struct pinctrl_dev":p->"struct pinctrl";
	"struct pinctrl_dev":desc->"struct pinctrl_desc"[color=blue];
	subgraph cluster_struct_pinctrl_desc{
		label="struct pinctrl_desc";
		"struct pinctrl_desc"[label="{
		const char *name;
    |<pins>struct pinctrl_pin_desc const *pins****pin脚描述符***
    |unsigned int npins;
    |const struct pinctrl_ops *pctlops;
    |const struct pinmux_ops *pmxops;
    |const struct pinconf_ops *confops;
    |struct module *owner;
	}"];
	}
	"struct pinctrl_desc":pins->"struct msm_pinctrl_soc_data":pins[arrowhead=none color=blue];
	"struct pinctrl_desc":pins->"struct pinctrl_pin_desc"[color=red];
	subgraph cluster_struct_pinctrl_pin_desc{
		label="struct pinctrl_pin_desc";
		"struct pinctrl_pin_desc"[label="{
			unsigned number
			|const char *name
			|void *drv_data
		}"];
	}

	subgraph cluster_struct_platform_device{
		label="struct platform_device";
		"struct platform_device"[label="{
		 const char  *name;
    	|int     id;
    	|bool        id_auto;
    	|<dev>struct device   dev;
    	|u32     num_resources;
    	|struct resource *resource;
    	|const struct platform_device_id *id_entry;
    	|char *driver_override
    	|struct mfd_cell *mfd_cell;
    	|struct pdev_archdata    archdata;
	}"];
	}
	"struct platform_device":dev->"struct device"[color=red];

	subgraph cluster_struct_device{
		label="struct device";
		"struct device"[label="{
		struct device  *parent
		|<private>struct device_private  *p
		|struct kobject kobj
		|const char  *init_name
		|const struct device_type *type
		|struct mutex        mutex
		|<bus>struct bus_type *bus
		|struct device_driver *driver
		|void     *platform_data
		|void     *driver_data
		|struct dev_pm_info  power
		|<pm_domain>struct dev_pm_domain    *pm_domain
    |struct irq_domain   *msi_domain;
    |<pins>struct dev_pin_info *pins;
    |struct list_head    msi_list;
    |int     numa_node
    |u64     *dma_mask
    |u64     coherent_dma_mask
    |unsigned long   dma_pfn_offset
    |struct device_dma_parameters *dma_parms;
    |struct list_head    dma_pools
    |struct dma_coherent_mem *dma_mem
    |struct cma *cma_area
    |struct dev_archdata archdata
    |struct device_node  *of_node
    |struct fwnode_handle    *fwnode
    |dev_t           devt
    |u32         id
    |spinlock_t      devres_lock;
    |struct list_head    devres_head;
    |struct klist_node   knode_class;
    |struct class        *class;
    |const struct attribute_group **groups
	|void    (*release)(struct device *dev);
    |struct iommu_group  *iommu_group;
    |bool            offline_disabled:1;
    |bool            offline:1;
	}"];
	}

	"struct device":pm_domain->"struct dev_pm_domain"[color=blue];
	"struct device":private->"struct device_private"[color=red];
	"struct device":bus->"struct bus_type"[color=red];
	subgraph cluster_struct_device_private{
		label="struct device_private";
		"struct device_private"[label="{
		struct klist klist_children
    |struct klist_node knode_parent
    |struct klist_node knode_driver
    |struct klist_node knode_bus
    |struct list_head deferred_probe
    |struct device *device
	}"];
	}

	subgraph cluster_struct_dev_pm_domain{
		label="struct dev_pm_domain";
		"struct dev_pm_domain"[label="{
			struct dev_pm_ops   ops;
    |void (*detach)(struct device *dev, bool power_off);
    |int (*activate)(struct device *dev);
    |void (*sync)(struct device *dev);
    |void (*dismiss)(struct device *dev);
		}"];
	}

	subgraph cluster_struct_klist{
		label="struct klist";
		"struct klist"[label="{
	|spinlock_t      k_lock
    |<list>struct list_head    k_list
    |void       (*get)(struct klist_node *)
    |void       (*put)(struct klist_node *)
		}"];
	}
	"struct klist":list->"struct list_head"[color=blue];

	subgraph cluster_struct_klist_iter{
		label="struct klist_iter";
		"struct klist_iter"[label="{
		|<i_klist>struct klist        *i_klist
    	|<cur>struct klist_node   *i_cur
	}"];
	}
	"struct klist_iter":i_klist->"struct klist"[color=purple];
	"struct klist_iter":cur->"struct klist_node"[color=purple];
	subgraph cluster_struct_klist_node{
		label="struct klist_node";
		"struct klist_node"[label="{
		void            *n_klist
    |<n_node>struct list_head    n_node;
    |struct kref     n_ref;
	}"];
	}
	"struct klist_node":n_node->"struct list_head"[color=red];
	subgraph cluster_struct_list_head{
		label="struct list_head";
		"struct list_head"[label="{
		struct list_head *next
		|struct list_head *prev
	}"];
	}

	subgraph cluster_struct_kobject{
		label="struct kobject";
		"struct kobject"[label="{
		const char      *name;
    |struct list_head    entry;
    |struct kobject      *parent;
    |struct kset     *kset;
    |struct kobj_type    *ktype;
    |struct kernfs_node  *sd
    |struct kref     kref;
    |struct delayed_work release;
    |unsigned int state_initialized:1;
    |unsigned int state_in_sysfs:1;
    |unsigned int state_add_uevent_sent:1;
    |unsigned int state_remove_uevent_sent:1;
    |unsigned int uevent_suppress:1;
	}"];
	}

	subgraph cluster_struct_msm_pinctrl{
		label="struct msm_pinctrl";
		"struct msm_pinctrl"[label="{
		struct device *dev;
    	|<pctrl>struct pinctrl_dev *pctrl
    	|struct gpio_chip chip
    	|struct notifier_block restart_nb
    	|int irq
    	|spinlock_t lock
    	|DECLARE_BITMAP(dual_edge_irqs, MAX_NR_GPIO)
    	|DECLARE_BITMAP(enabled_irqs, MAX_NR_GPIO)
    	|<soc>const struct msm_pinctrl_soc_data *soc
    	|void __iomem *regs
		}"];
	}
	"struct msm_pinctrl":pctrl->"struct pinctrl_dev"[color=purple];
	"struct msm_pinctrl":soc->"struct msm_pinctrl_soc_data"[color=blue];

	subgraph cluster_struct_msm_pinctrl_soc_data{
		label="struct msm_pinctrl_soc_data";
		bgcolor="pink";
		"struct msm_pinctrl_soc_data"[label="{
	|<pins>const struct pinctrl_pin_desc *pins\n
	an array describe all pins the controller affects
    |unsigned npins
    |<functions>const struct msm_function *functions\n
    an array of all mux function controller supports
    |unsigned nfunctions;
    |const struct msm_pingroup *groups;
    |unsigned ngroups;
    |unsigned ngpios;
		}"];
	}
	"struct msm_pinctrl_soc_data":functions->"struct msm_function"[color=red];
	subgraph cluster_struct_msm_function{
		label="struct msm_function";
		bgcolor="cyan";
		"struct msm_function"[label="{
		const char *name
    	|const char * const *groups
    	|unsigned ngroups
	}"];
	}

	subgraph cluster_struct_pinctrl_map{
		label="struct pinctrl_map";
		"struct pinctrl_map"[label="{
		const char *dev_name
    |const char *name
    |enum pinctrl_map_type type;
    |const char *ctrl_dev_name;
	|{struct pinctrl_map_mux mux|struct pinctrl_map_configs configs}
	}"];
	}

	subgraph cluster_struct_msm_pinctrl_dd{
		label="struct msm_pinctrl_dd";
		"struct msm_pinctrl_dd"[label="{
	 |void __iomem *base
    |int irq
    |unsigned int num_pins
    |struct msm_pindesc *msm_pindesc
    |unsigned int num_pintypes
    |<msm_pintype>struct msm_pintype_info *msm_pintype
    |<pctl>struct pinctrl_desc pctl
    |<pctl_dev>struct pinctrl_dev *pctl_dev
    |struct msm_pin_grps *pin_grps
    |unsigned int num_grps
    |struct  msm_pmx_funcs *pmx_funcs
    |unsigned int num_funcs
    |struct device *dev
		}"];
	}
	"struct msm_pinctrl_dd":msm_pintype->"struct msm_pintype_info"[color=brown];
	"struct msm_pinctrl_dd":pctl->"struct pinctrl_desc pctl"[color=blue];
	"struct msm_pinctrl_dd":pctl_dev->"struct pinctrl_dev"[color=blue];
	"struct msm_pinctrl_dd"->"struct msm_tlmm_desc"[arrowhead=none color=blue];

	subgraph cluster_struct_msm_tlmm_desc{
		label="struct msm_tlmm_desc";
		"struct msm_tlmm_desc"[label="{
	void __iomem *base;
    |int irq;
    |unsigned int num_pintypes;
    |<pintypes>struct msm_pintype_info *pintypes;
		}"];
	}
	subgraph cluster_struct_msm_pintype_info{
		label="struct msm_pintype_info";
		bgcolor="pink";
		"struct msm_pintype_info"[label="{
	|int (*prg_cfg)(uint pin_no, unsigned long *config,
               \nbool rw, const struct msm_pintype_info *pinfo);
    |void (*prg_func)(uint pin_no, u32 func, bool enable,
             \nconst struct msm_pintype_info *pinfo);
    |int (*init_irq)(int irq, struct msm_pintype_info *pinfo,
            \nstruct device *tlmm_dev);
    |void (*set_reg_base)(void __iomem *tlmm_base,
                 \nstruct msm_pintype_info *pinfo);
    |void __iomem *reg_base;
    |const char *name;
    |u32 num_pins;
    |int pin_start;
    |int pin_end;
    |<gc>struct gpio_chip gc;
    |struct msm_tlmm_irq_chip *irq_chip;
    |bool supports_gpio;
    |struct pinctrl_gpio_range grange;
    |struct device_node *node;
    |const struct msm_pintype_data *pintype_data;
	}"];
	}
	"struct msm_tlmm_desc":pintypes->"struct msm_pintype_info"[color=blue];
	"struct msm_pintype_info":gc->"struct gpio_chip"[color=red];

	subgraph cluster_struct_gpio_chip{
		label="struct gpio_chip";
		"struct gpio_chip"[label="{
			const char      *label;
    |struct device       *dev;
    |struct module       *owner;
    |struct list_head        list;

    |int         (*request)(struct gpio_chip *chip,
                        \nunsigned offset);
    |void            (*free)(struct gpio_chip *chip,
                        \nunsigned offset);
    |int         (*get_direction)(struct gpio_chip *chip,
                        \nunsigned offset);
    |int         (*direction_input)(struct gpio_chip *chip,
                        \nunsigned offset);
    |int         (*get)(struct gpio_chip *chip,
                        \nunsigned offset);
    |int         (*direction_output)(struct gpio_chip *chip,
                        \nunsigned offset, int value);
    |int         (*set_debounce)(struct gpio_chip *chip,
                        \nunsigned offset, unsigned debounce)
    |void    (*set)(struct gpio_chip *chip,
                \nunsigned offset, int value)
    |int     (*to_irq)(struct gpio_chip *chip,
                        \nunsigned offset);
    |void            (*dbg_show)(struct seq_file *s,
                        \nstruct gpio_chip *chip);
    |int         base
    |u16         ngpio;
    |struct gpio_desc    *desc;
    |const char      *const *names;
    |unsigned        can_sleep:1;
    |unsigned        exported:1;
    |struct device_node *of_node;
    |int of_gpio_n_cells;
    |int (*of_xlate)(struct gpio_chip *gc,
                \nconst struct of_phandle_args *gpiospec, u32 *flags)
	|struct list_head pin_ranges
		}"];
	}


}
